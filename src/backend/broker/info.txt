Po co nam broker??

Hermetyzacja: reszta aplikacji (strategie, backend loop, frontend) nie musi znać szczegółów SDK Alpaca. Ma prosty interfejs: „złóż zlecenie”, „sprawdź konto”, „pokaż pozycje”.
Bezpieczeństwo: jeden „zawór” na ryzyko (DRY_RUN, walidacja parametrów, sanity-check rynku).
Testowalność: łatwo podmienisz prawdziwego brokera na mocka w testach i backteście.
Rozszerzalność: w przyszłości podłączysz innego brokera bez zmiany logiki strategii

1) Kontrakt/interfejs klasy AlpacaBroker

Docelowo metody (sygnatury i nazwy zachowujemy, wnętrze zaimplementujemy później):
get_account(): podstawowe pola (cash, equity, buying_power, status konta).
get_clock(): czy rynek otwarty, kiedy next_open/next_close (UTC i lokalny).
submit_market_order(symbol, qty, side, tif="day"): składa albo symuluje zlecenie.
get_open_positions(): lista pozycji (symbol, qty, avg_price, unrealized PnL).
cancel_all(): anuluje wszystkie zlecenia oczekujące.
Dobrze, żeby każda metoda zwracała nasze proste struktury (np. dict/TypedDict/Pydantic model), a nie surowe obiekty SDK. To izoluje nas od zmian w bibliotece.

2) Tryb DRY_RUN (krytyczne!)
Źródło prawdy: flaga DRY_RUN z .env.

Zachowanie:
Gdy DRY_RUN=true: żadnych żądań „piszących” (submit, cancel) do Alpaca — tylko logujemy co byśmy zrobili i zwracamy „symulowane” ID zlecenia.
Gdy DRY_RUN=false: normalnie uderzamy do Alpaca.
Po co: bezpieczne testy i szybkie development runy.

3) Walidacja wejścia i sanity-checki

Przed wysłaniem jakiegokolwiek zlecenia:
Symbol: niepusty string, CAPS; opcjonalnie whitelist (AAPL, MSFT…) na MVP.
Qty: > 0 i całkowite (dla akcji); gdy wprowadzimy krypto/FRAC, rozszerzymy.
Side: enum {BUY, SELL}.
Time in Force (TIF): na start tylko "day".
Rynek: jeśli rynek zamknięty (clock.is_open = False) i nie mamy rozszerzonej sesji, loguj i nie wysyłaj market ordera (chyba że explicite wymusisz).
Buying power: przy BUY sprawdź, czy wystarczy środków (opcjonalnie na start).

4) Obsługa błędów i retry

Zdefiniuj prostą taksonomię wyjątków (naszych, nie z SDK), np.:
BrokerAuthError — problemy z kluczem/sekretem.
BrokerRateLimitError — 429 / limit zapytań.
BrokerOrderRejected — broker odrzucił zlecenie (powód w message).
BrokerNetworkError — chwilowe kłopoty z siecią.
BrokerValidationError — zły input (np. qty ≤ 0).

Retry/backoff:
Dla NetworkError i RateLimitError – krótki exponential backoff (np. 0.5s, 1s, 2s, max 3 próby).
Nigdy nie retry’uj idempotency-risk operacji bez ochrony (patrz niżej).

5) Idempotencja i „at-least-once”

Zdarza się: timeout po wysłaniu zlecenia i nie wiesz, czy doszło. Rozwiązania:
Idempotency key (jeżeli broker wspiera – Alpaca dla orders akceptuje client_order_id). Generuj client_order_id po naszej stronie (np. botname-timestamp-uuid) i zapisuj w logach/DB.
Jeżeli dostaniesz timeout — sprawdź listę zleceń po client_order_id przed kolejną próbą.

6) Logowanie i telemetry

Poziomy: INFO dla akcji użytkowych (zlecenie wysłane), DEBUG dla payloadów/response, WARNING/ERROR dla wyjątków.
Loguj zawsze: client_order_id, symbol, qty, side, tif, dry_run, wynik (ID/status).
Przy get_account/get_clock: loguj skrót (equity, buying_power, is_open, next_open/close).

7) Zależność od SDK

Masz alpaca-trade-api==3.0.1 — OK na start. Warto:
Owinąć wywołania SDK w cienkie adaptery (jedno miejsce importu SDK), żeby migracja do alpaca-py kiedyś była bezbolesna.
Nie „przeciekać” obiektów SDK poza broker/.

8) Testowanie (jak sprawdzimy to bez kodu)

Test manualny (kryterium z zadania):
Uruchom skrypt testowy (np. src/app/__main__.py) który:
woła get_account() i get_clock(),
wywołuje submit_market_order("AAPL", 1, "buy").

W trybie DRY_RUN=true: w logu widzisz „symuluję market BUY AAPL x1…”.
W trybie DRY_RUN=false: po odpaleniu paper trading faktycznie pojawia się zlecenie (sprawdzisz w panelu Alpaca).

Testy jednostkowe (później):
Mock SDK → sprawdzasz walidację, idempotency key, mapowanie błędów.
Testy „integracyjne light”:
Rzeczywiste get_account/get_clock (bo są tylko READ) + DRY_RUN dla write.

9) Krawędzie i pułapki, o których warto pamiętać

Strefy czasowe: clock zwraca czasy w UTC — loguj też w lokalnej, żeby nie pomylić sesji.
Market order poza sesją: Alpaca może odrzucić. W przyszłości dodamy extended_hours=True oraz limit orders.
Brak płynności / halted: even market order może zostać rejected.
Rate limits: przy pętli live trzeba ograniczyć częstotliwość zapytań (np. nie pinguj co 200ms).
Partial fills: dziś ignorujemy, później dodamy tracking statusu filled_qty, pending_new, partially_filled, itp.
Cancel all: nie rób tego w panice bez logiki — przyda się whitelist (np. cancel tylko zlecenia tego bota).

10) Minimalne modele danych (żeby frontend/strategie miały stabilny shape)

Na poziomie koncepcji (później ubierzemy to w Pydantic/TypedDict):
Account: { equity: float, cash: float, buying_power: float, status: str }
Clock: { is_open: bool, next_open: datetime, next_close: datetime }
OrderResult: { id: str, client_order_id: str, status: str, symbol: str, qty: int, side: str, submitted_at: datetime }
Position: { symbol: str, qty: float, avg_price: float, market_value: float, unrealized_pl: float }

11) Integracja z resztą aplikacji (po co to teraz)

Strategia woła tylko AlpacaBroker.submit_market_order(...) i nie obchodzi jej jakiego SDK używasz.
Frontend może czytać get_account()/get_open_positions() i wyświetlać dane bez dotykania SDK.
Egzekucja/risk (następny moduł) dostaje spójne API — łatwiej dodać limity, SL/TP, sizing.